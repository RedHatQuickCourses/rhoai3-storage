= The Physics of AI Storage: Primitives & Protocols
:navtitle: Storage Architecture
:imagesdir: ../images
:role: Technical Deep Dive
:audience: Platform Engineers & Architects
:description: Understanding the impact of storage protocols on Node I/O, Caching, and Pod Stability.

[.lead]
*To build a stable platform, you must respect the physics of the underlying infrastructure.*

In standard web development, a 500MB container image is considered "large." In AI, a 70GB model is considered "medium."

When you try to move objects of this size using standard Kubernetes patterns, things break. Nodes run out of disk space. Networks saturate. Pods enter crash loops.

This module breaks down the **Three Storage Tiers** of RHOAI 3 and explains the mechanical differences between them so you can architect for stability.

== 1. The "EmptyDir" Problem (Why S3 Fails at Scale)

The most common mistake Platform Engineers make is treating Object Storage (S3) as a universal solution for Model Serving.

When a Model Server connects to an S3 bucket to load a model, it typically follows this workflow:

 1.  **Init:** An `initContainer` starts.
 2.  **Download:** It pulls the 50GB model file from S3.
 3.  **Write:** It writes that file to an `emptyDir` volume (ephemeral storage) on the Node's disk.
 4.  **Serve:** The main container mounts that volume and loads the model into RAM.



=== The Architectural Risk
 * **Node Thrashing:** If you schedule 4 replicas of a 50GB model on one node, you just demanded **200GB of ephemeral disk space**. If the node doesn't have it, the Kubelet will start **evicting pods**.
 * **Bandwidth Storms:** If a node reboots, all 4 pods restart and try to download 200GB simultaneously, saturating the network interface.
 * **Latency:** The pod is not "Ready" until the download finishes. This can take 10-20 minutes.

**Strategic Rule:** Use S3 for *Training Data* (Ingestion). Do not use it for *Production Serving* of large models.

== 2. The Velocity Tier: OCI Modelcars (The Solution)

To solve the "EmptyDir" problem, RHOAI 3 supports the **OCI Protocol** (Modelcars). This treats the model not as a *file*, but as a *Container Image*.

=== The Physics of OCI
When you define a Data Connection with `opendatahub.io/connection-type-protocol: "oci"`, the cluster uses the underlying container runtime (CRI-O) to pull the data.

 * **Layer Caching:** If 10 replicas start on the same node, CRI-O pulls the image layers **once**. All 10 pods share the read-only layer on the disk.
 * **Zero Duplication:** You use 50GB of disk space, not 500GB.
 * **Instant Startup:** If the image is already cached on the node, startup time is near-instant.



== 3. The Persistence Tier: Cluster Storage (PVCs)

While OCI is for speed, **Persistent Volume Claims (PVCs)** are for **state** and **isolation**.

=== RWO vs. RWX: The Physics of Access
You must choose the right Access Mode based on the physics of your storage backend.

[cols="1,2,2"]
|===
| Access Mode | The Analogy | The Architectural Constraint

| **ReadWriteOnce (RWO)**
| **The Hard Drive**
| **Block Storage.** It physical mounts a block device to a specific Node. It cannot be mounted to two nodes at once. If the pod moves, the drive must unmount and remount.
| *Best For:* User Scratchpads, Databases, Single-User Notebooks.

| **ReadWriteMany (RWX)**
| **The File Server**
| **Network File System (NFS/CephFS).** It connects via the network. Multiple nodes can mount it simultaneously.
| *Best For:* Shared Team Folders, Distributed Training, Air-Gapped Model Hosting.
|===

=== The "Retain" Policy (Critical Safety)
By default, when a user deletes a PVC, Kubernetes **deletes the data**.
For "Golden Datasets" or "Production Models" stored on PVCs, you must change the `ReclaimPolicy` to `Retain`. This ensures that even if a namespace is nuked, the underlying storage remains safe.

== 4. The Abstraction Tier: The API Primitives

To configure any of the above, RHOAI 3 uses two specific API resources.

=== A. The Connection Type (The Template)

An administrator-defined resource that dictates the *schema* of a connection.

 * *Purpose:* Governance. It forces users to provide specific fields (e.g., "Endpoint", "Region").
 * *Role:* The Platform Engineer creates this **once**.

=== B. The Data Connection (The Instance)
A Kubernetes Secret that contains the actual credentials.

 * *Purpose:* Injection. It maps the values to Environment Variables inside the Pod.
 * *Role:* The User (or Automation Script) creates this **per project**.

[WARNING]
.Deprecation Alert
====
RHOAI 3 has standardized the annotations.
 * **Deprecated:** `opendatahub.io/connection-type-ref`
 * **Required:** `opendatahub.io/connection-type-protocol` (Values: `s3`, `oci`, `uri`)
====

== Summary: The Decision Matrix

As a Platform Engineer, here is your decision tree:

 1.  **Ingesting Raw Data?** -> **S3 Connection.**
 2.  **Serving Large Models in Production?** -> **OCI Connection** (for caching).
 3.  **Collaborating with a Team?** -> **RWX PVC.**
 4.  **Air-Gapped Environment?** -> **RWX PVC** (with `Retain` policy).

*Now that we understand the physics, let's look at the "Sharp Edges"â€”the specific configurations that cause outages.*